// Copyright 2016 Rafael Lorandi <coolparadox@gmail.com>
// This file is part of Raw, a binary encoder of Go types.
//
// Raw is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Raw is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Raw. If not, see <http://www.gnu.org/licenses/>.

/*
Package raw implements binary serialization of Go types.

Basics

Create a variable to serve as a placeholder to the typed data you want to
serialize, and use New to create an encoder for it:

	type MyType struct {
		Id uint32
		Name string
		Age uint8
	}
	var myData MyType
	encoder, err := raw.New(&myData)
	if err != nil {
		panic(fmt.Errorf("failed to create encoder: %s", err))
	}

To serialize data, use Marshal:

	myData.id = 2
	myData.name = "John Doe"
	myData.age = 47
	var buf bytes.Buffer
	var n int
	n, err = encoder.Marshal(&buf)
	if err != nil {
		panic(fmt.Errorf("marshal failed: %s", err))
	}
	fmt.Printf("%v in %v bytes --> %v\n", myData, n, buf.Bytes())

To recover the typed value of a byte sequence previously generated by Marshal,
use Unmarshal:

	myData = struct {}
	n, err := encoder.Unmarshal(&buf)
	if err != nil {
		panic(fmt.Errorf("unmarshal failed: %s", err))
	}
	fmt.Printf("%v bytes recovered --> %v\n", n, myData)

Suported Types

Types of the following kinds are supported by Raw:
bool,
int8, int16, int32, int64,
uint8, uint16, uint32, uint64,
float32, float64,
complex64, complex128,
string,
array of any supported type,
map of any supported type,
pointer to any supported type,
slice of any supported type,
struct with fields of any supported type.

Unsupported Types

Types of the following kinds are not supported:
int, uint, uintptr (their size is platform dependent);
unsafe pointer (not meaningful across systems);
chan, func, interface (language plumbing).

Issues

The placeholder variable (see New)
is the access point to unmarshaled data for a given encoder.
The encoder is eternally bound to its placeholder variable.

Unmarshal of array, map, ptr or slice always creates new values
(there is no reuse of allocated resources).

A nil map or slice is marshaled as a non nil value with zero elements.

Structs must have all fields exported.

Marshaled data doesn't contain type information.
It's up to the programmer to ensure that unmarshal is performed by an
encoder created
after the same type kind of the encoder that generated the marshaled data.
One way of achieving this is to compare Encoders's signatures (see Signature).

*/
package raw

import "fmt"
import "io"
import "reflect"

/*
Encoder can transform typed data to a sequence of bytes and vice-versa.

Signature answers a textual representation of the type kind of its placeholder
variable (see New).

Marshal converts typed data of the placeholder variable
to a sequence of bytes and writes it to an io.Writer.
Returns the number of bytes written.

Unmarshal reads a sequence of bytes from an io.Reader
and converts it to typed data stored in the placeholder variable.
Returns the number of bytes read.
*/
type Encoder interface {
	Signature() string
	Marshal(io.Writer) (int, error)
	Unmarshal(io.Reader) (int, error)
}

/*
New creates an Encoder for a type.

It must be given a pointer to a variable of any supported type
(see Supported Types).
The resulting Encoder will use this variable as a placeholder of typed data
during work.

Returns an Encoder bound to the placeholder variable.
*/
func New(placeholder interface{}) (Encoder, error) {
	return makeEncoder(reflect.ValueOf(placeholder))
}

// makeEncoder recursively creates an Encoder.
func makeEncoder(v reflect.Value) (Encoder, error) {
	var err error
	if v.Kind() != reflect.Ptr {
		return nil, fmt.Errorf("placeholder variable must be passed by reference")
	}
	k := v.Elem().Kind()
	switch k {
	default:
		return nil, fmt.Errorf("unsupported data type: %s", k)
	case reflect.Uint8:
		return uint8Encoder{v.Interface().(*uint8)}, nil
	case reflect.Uint16:
		return uint16Encoder{v.Interface().(*uint16)}, nil
	case reflect.Uint32:
		return uint32Encoder{v.Interface().(*uint32)}, nil
	case reflect.Uint64:
		return uint64Encoder{v.Interface().(*uint64)}, nil
	case reflect.Int8:
		return int8Encoder{v.Interface().(*int8)}, nil
	case reflect.Int16:
		return int16Encoder{v.Interface().(*int16)}, nil
	case reflect.Int32:
		return int32Encoder{v.Interface().(*int32)}, nil
	case reflect.Int64:
		return int64Encoder{v.Interface().(*int64)}, nil
	case reflect.Float32:
		return float32Encoder{v.Interface().(*float32)}, nil
	case reflect.Float64:
		return float64Encoder{v.Interface().(*float64)}, nil
	case reflect.Complex64:
		return complex64Encoder{v.Interface().(*complex64)}, nil
	case reflect.Complex128:
		return complex128Encoder{v.Interface().(*complex128)}, nil
	case reflect.Bool:
		return boolEncoder{v.Interface().(*bool)}, nil
	case reflect.String:
		return stringEncoder{v.Interface().(*string)}, nil
	case reflect.Array:
		ws := reflect.New(v.Type().Elem().Elem())
		w, err := makeEncoder(ws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for array: %s", err)
		}
		return arrayEncoder{worker: w, workerStore: ws, store: v}, nil
	case reflect.Slice:
		ws := reflect.New(v.Type().Elem().Elem())
		w, err := makeEncoder(ws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for slice: %s", err)
		}
		return sliceEncoder{worker: w, workerStore: ws, store: v}, nil
	case reflect.Map:
		kws := reflect.New(v.Type().Elem().Key())
		kw, err := makeEncoder(kws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for map: %s", err)
		}
		ews := reflect.New(v.Type().Elem().Elem())
		ew, err := makeEncoder(ews)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for map: %s", err)
		}
		return mapEncoder{keyWorker: kw, keyWorkerStore: kws, elemWorker: ew, elemWorkerStore: ews, store: v}, nil
	case reflect.Struct:
		v = v.Elem()
		n := v.NumField()
		store := make([]Encoder, n, n)
		for i := 0; i < n; i++ {
			f := v.Type().Field(i)
			if f.PkgPath != "" {
				return nil, fmt.Errorf("struct field '%s' is unexported", f.Name)
			}
			store[i], err = makeEncoder(v.Field(i).Addr())
			if err != nil {
				return nil, fmt.Errorf("cannot make encoder for struct field %s: %s", v.Type().Field(i).Name, err)
			}
		}
		return structEncoder{store}, nil
	case reflect.Ptr:
		ws := reflect.New(v.Type().Elem().Elem())
		w, err := makeEncoder(ws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for pointer: %s", err)
		}
		return ptrEncoder{worker: w, workerStore: ws, store: v}, nil
	}
}
