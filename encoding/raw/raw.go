// Copyright 2016 Rafael Lorandi <coolparadox@gmail.com>
// This file is part of Raw, a binary encoder of Go types.
//
// Raw is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Raw is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Raw. If not, see <http://www.gnu.org/licenses/>.

/*
Package raw implements binary serialization of Go types.

Basics

Create a variable to serve as a placeholder to the typed data you want to
serialize, and use New to create an encoder for it:

	type MyType struct {
		id uint32
		name string
		age uint8
	}
	var myData MyType
	encoder, err := raw.New(&myData)
	if err != nil {
		panic(fmt.Errorf("failed to create encoder: %s", err))
	}

To serialize data, use Marshal:

	myData.id = 2
	myData.name = "John Doe"
	myData.age = 47
	var buf bytes.Buffer
	var n int
	n, err = encoder.Marshal(&buf)
	if err != nil {
		panic(fmt.Errorf("marshal failed: %s", err))
	}
	fmt.Printf("%v in %v bytes --> %v\n", myData, n, buf.Bytes())

To recover the typed value of a byte sequence previously generated by Marshal,
use Unmarshal:

	myData = struct {}
	n, err := encoder.Unmarshal(&buf)
	if err != nil {
		panic(fmt.Errorf("unmarshal failed: %s", err))
	}
	fmt.Printf("%v bytes recovered --> %v\n", n, myData)

Suported Types

 - bool
 - int8, int16, int32, int64
 - uint8, uint16, uint32, uint64
 - float32, float64
 - complex64, complex128
 - string
 - array of any supported type
 - map of any supported type
 - ptr to any supported type
 - slice of any supported type
 - struct with fields of any supported type

Unsupported Types

 - int, uint, uintptr (depth is platform dependent)
 - unsafe pointer (not meaningful across systems)
 - chan, func, interface (language plumbing)

Issues

An encoder is eternally bound to a variable that serves as the access point to unmarshaled (typed) data.

Marshaled data doesn't contain type information.
It's up to the programmer to ensure data is unmarshaled by an encoder created after the same underlying type. See Signature method.

Unmarshal of array, map, ptr or slice always creates new values (there is no reuse of allocated resources).

A nil map or slice is marshaled as a non nil value with zero elements.

*/
package raw

import "fmt"
import "io"
import "reflect"

// Encoder can transform typed data to a sequence of bytes and vice-versa.
type Encoder interface {

	// Signature answers a textual representation of the underlying type the encoder was created after.
	Signature() string

	// Marshal converts typed data of the placeholder variable (see New) to a sequence of bytes and writes it to an io.Writer.
	// Returns the number of bytes written.
	Marshal(io.Writer) (int, error)

	// Unmarshal reads a sequence of bytes from an io.Reader and converts it to typed data stored in the placeholder variable (see New).
	// Returns the number of bytes read.
	Unmarshal(io.Reader) (int, error)
}

// New creates an Encoder for a type.
//
// Parameter holder must be a pointer to a variable of any supported type (see Supported Types).
// The created Encoder will use this variable as a placeholder of typed data during work.
//
// Returns an Encoder for the type of the placeholder variable.
func New(holder interface{}) (Encoder, error) {
	return makeEncoder(reflect.ValueOf(holder))
}

// makeEncoder recursively creates an Encoder.
func makeEncoder(v reflect.Value) (Encoder, error) {
	var err error
	if v.Kind() != reflect.Ptr {
		return nil, fmt.Errorf("placeholder variable must be passed by reference")
	}
	k := v.Elem().Kind()
	switch k {
	default:
		return nil, fmt.Errorf("unsupported data type: %s", k)
	case reflect.Uint8:
		return uint8Encoder{v.Interface().(*uint8)}, nil
	case reflect.Uint16:
		return uint16Encoder{v.Interface().(*uint16)}, nil
	case reflect.Uint32:
		return uint32Encoder{v.Interface().(*uint32)}, nil
	case reflect.Uint64:
		return uint64Encoder{v.Interface().(*uint64)}, nil
	case reflect.Int8:
		return int8Encoder{v.Interface().(*int8)}, nil
	case reflect.Int16:
		return int16Encoder{v.Interface().(*int16)}, nil
	case reflect.Int32:
		return int32Encoder{v.Interface().(*int32)}, nil
	case reflect.Int64:
		return int64Encoder{v.Interface().(*int64)}, nil
	case reflect.Float32:
		return float32Encoder{v.Interface().(*float32)}, nil
	case reflect.Float64:
		return float64Encoder{v.Interface().(*float64)}, nil
	case reflect.Complex64:
		return complex64Encoder{v.Interface().(*complex64)}, nil
	case reflect.Complex128:
		return complex128Encoder{v.Interface().(*complex128)}, nil
	case reflect.Bool:
		return boolEncoder{v.Interface().(*bool)}, nil
	case reflect.String:
		return stringEncoder{v.Interface().(*string)}, nil
	case reflect.Array:
		ws := reflect.New(v.Type().Elem().Elem())
		w, err := makeEncoder(ws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for array: %s", err)
		}
		return arrayEncoder{worker: w, workerStore: ws, store: v}, nil
	case reflect.Slice:
		ws := reflect.New(v.Type().Elem().Elem())
		w, err := makeEncoder(ws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for slice: %s", err)
		}
		return sliceEncoder{worker: w, workerStore: ws, store: v}, nil
	case reflect.Map:
		kws := reflect.New(v.Type().Elem().Key())
		kw, err := makeEncoder(kws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for map: %s", err)
		}
		ews := reflect.New(v.Type().Elem().Elem())
		ew, err := makeEncoder(ews)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for map: %s", err)
		}
		return mapEncoder{keyWorker: kw, keyWorkerStore: kws, elemWorker: ew, elemWorkerStore: ews, store: v}, nil
	case reflect.Struct:
		v = v.Elem()
		n := v.NumField()
		store := make([]Encoder, n, n)
		for i := 0; i < n; i++ {
			f := v.Type().Field(i)
			if f.PkgPath != "" {
				return nil, fmt.Errorf("struct field '%s' is unexported", f.Name)
			}
			store[i], err = makeEncoder(v.Field(i).Addr())
			if err != nil {
				return nil, fmt.Errorf("cannot make encoder for struct field %s: %s", v.Type().Field(i).Name, err)
			}
		}
		return structEncoder{store}, nil
	case reflect.Ptr:
		ws := reflect.New(v.Type().Elem().Elem())
		w, err := makeEncoder(ws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for pointer: %s", err)
		}
		return ptrEncoder{worker: w, workerStore: ws, store: v}, nil
	}
}
