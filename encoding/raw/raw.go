// Copyright 2016 Rafael Lorandi <coolparadox@gmail.com>
// This file is part of Raw, a binary encoder of Go types.
//
// Raw is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Raw is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Raw. If not, see <http://www.gnu.org/licenses/>.

/*
Package raw implements binary serialization of Go types.

Basics

Create a variable to serve as a placeholder to the typed data you want to
serialize, and use New to create an encoder for it:

	type MyType struct {
		id uint32
		name string
		age uint8
	}
	var myData MyType
	encoder, err := raw.New(&myData)
	if err != nil {
		panic(fmt.Errorf("failed to create encoder: %s", err))
	}

To serialize data, use Marshal:

	myData.id = 2
	myData.name = "John Doe"
	myData.age = 47
	var buf bytes.Buffer
	var n int
	n, err = encoder.Marshal(&buf)
	if err != nil {
		panic(fmt.Errorf("marshal failed: %s", err))
	}
	fmt.Printf("%v in %v bytes --> %v\n", myData, n, buf.Bytes())

To recover the typed value of a byte sequence previously generated by Marshal,
use Unmarshal:

	myData = struct {}
	n, err := encoder.Unmarshal(&buf)
	if err != nil {
		panic(fmt.Errorf("unmarshal failed: %s", err))
	}
	fmt.Printf("%v bytes recovered --> %v\n", n, myData)

*/
package raw

import "fmt"
import "io"
import "reflect"

type Encoder interface {
	Signature() string
	Marshal(io.Writer) (int, error)
	Unmarshal(io.Reader) (int, error)
}

func New(data interface{}) (Encoder, error) {
	return makeEncoder(reflect.ValueOf(data))
}

func makeEncoder(v reflect.Value) (Encoder, error) {
	var err error
	if v.Kind() != reflect.Ptr {
		return nil, fmt.Errorf("storage variable must be passed by reference")
	}
	k := v.Elem().Kind()
	switch k {
	default:
		return nil, fmt.Errorf("unsupported data type: %s", k)
	case reflect.Uint8:
		return uint8Encoder{v.Interface().(*uint8)}, nil
	case reflect.Uint16:
		return uint16Encoder{v.Interface().(*uint16)}, nil
	case reflect.Uint32:
		return uint32Encoder{v.Interface().(*uint32)}, nil
	case reflect.Uint64:
		return uint64Encoder{v.Interface().(*uint64)}, nil
	case reflect.Int8:
		return int8Encoder{v.Interface().(*int8)}, nil
	case reflect.Int16:
		return int16Encoder{v.Interface().(*int16)}, nil
	case reflect.Int32:
		return int32Encoder{v.Interface().(*int32)}, nil
	case reflect.Int64:
		return int64Encoder{v.Interface().(*int64)}, nil
	case reflect.Float32:
		return float32Encoder{v.Interface().(*float32)}, nil
	case reflect.Float64:
		return float64Encoder{v.Interface().(*float64)}, nil
	case reflect.Complex64:
		return complex64Encoder{v.Interface().(*complex64)}, nil
	case reflect.Complex128:
		return complex128Encoder{v.Interface().(*complex128)}, nil
	case reflect.Bool:
		return boolEncoder{v.Interface().(*bool)}, nil
	case reflect.String:
		return stringEncoder{v.Interface().(*string)}, nil
	case reflect.Array:
		ws := reflect.New(v.Type().Elem().Elem())
		w, err := makeEncoder(ws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for array: %s", err)
		}
		return arrayEncoder{worker: w, workerStore: ws, store: v}, nil
	case reflect.Slice:
		ws := reflect.New(v.Type().Elem().Elem())
		w, err := makeEncoder(ws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for slice: %s", err)
		}
		return sliceEncoder{worker: w, workerStore: ws, store: v}, nil
	case reflect.Map:
		kws := reflect.New(v.Type().Elem().Key())
		kw, err := makeEncoder(kws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for map: %s", err)
		}
		ews := reflect.New(v.Type().Elem().Elem())
		ew, err := makeEncoder(ews)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for map: %s", err)
		}
		return mapEncoder{keyWorker: kw, keyWorkerStore: kws, elemWorker: ew, elemWorkerStore: ews, store: v}, nil
	case reflect.Struct:
		v = v.Elem()
		n := v.NumField()
		store := make([]Encoder, n, n)
		for i := 0; i < n; i++ {
			f := v.Type().Field(i)
			if f.PkgPath != "" {
				return nil, fmt.Errorf("struct field '%s' is unexported", f.Name)
			}
			store[i], err = makeEncoder(v.Field(i).Addr())
			if err != nil {
				return nil, fmt.Errorf("cannot make encoder for struct field %s: %s", v.Type().Field(i).Name, err)
			}
		}
		return structEncoder{store}, nil
	case reflect.Ptr:
		ws := reflect.New(v.Type().Elem().Elem())
		w, err := makeEncoder(ws)
		if err != nil {
			return nil, fmt.Errorf("cannot make encoder for pointer: %s", err)
		}
		return ptrEncoder{worker: w, workerStore: ws, store: v}, nil
	}
}
